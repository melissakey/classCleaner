# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Bayesian Filtering Probablity
#' Calculate the probability of P(i in Group k | data) for all entities in Group k using simulated draws from a hierarchical Dirichlet sampling scheme.
#' @param assignment A character vector containing the group to which each entity has been classified
#' @param D A numeric vector containing the distance or quasi-distance between the entities.
#' @param k A string identifying the group on which to apply the filtering.
#' @param B The number of simulated draws to use in determining the distribution of the means.
#'
#' @details
#' For each entity in group k, this function estimates the probability the mean distance between it and another entity in group k has the same distribution as a mean distance from it and another group.
#' Under the null hypothesis, the mean distance is no different, and we remove it from the group.
#' Under the alterantive hypothesis, the mean distance is closer, and we conclude that the entity truly belongs to the group.
#'
#' @export
#' @examples
#' # we use a matrix of indices to illustrate how the draws are made:
#' set.seed(23)
#' N <- 20
#' K <- 4
#' assignment <- sample(LETTERS[1:K], N, replace = TRUE)
#'
#' m <- matrix(runif(N^2), N, N)
#' diag(m) = 0
#' m <- m %*% m
#' k <- 'A'
#' i <- 1
#' probs <- estimate_probability(assignment, m, "A", 1000)
#' hist(means)
NULL

bayesian_prob <- function(omega, omega0, assignment, D, k, B, prior) {
    .Call(`_classCleaner_bayesian_prob`, omega, omega0, assignment, D, k, B, prior)
}

empirical_prob <- function(assignment, D, k) {
    .Call(`_classCleaner_empirical_prob`, assignment, D, k)
}

get_estimated_prob <- function(omega, omega0, k_indices, class_table, k, assignment, D, B, observed_means, prior) {
    .Call(`_classCleaner_get_estimated_prob`, omega, omega0, k_indices, class_table, k, assignment, D, B, observed_means, prior)
}

get_observed_means <- function(N, omega, omega0, k_indices, D) {
    .Call(`_classCleaner_get_observed_means`, N, omega, omega0, k_indices, D)
}

get_simulated_means <- function(omega, omega0, K, simulated_ks, k, i, assignment, k_indices, D, prior) {
    .Call(`_classCleaner_get_simulated_means`, omega, omega0, K, simulated_ks, k, i, assignment, k_indices, D, prior)
}

#' @title Identify Outliers
#' 
#' @description Calculate the probability that each entity in a group with at least 2 entities actually belongs
#' @param assignment A character vector containing the group to which each entity has been classified
#' @param D A numeric vector containing the distance or quasi-distance between the entities.
#' @param B The number of simulated draws to use in determining the distribution of the means.
#' @param min_group_size The smallest number of entities required to perform filtering.  (Must be at least 2)
#' @param labels entity-specific labels.
#'
#' @details
#' For each entity in group k, this function estimates the probability the mean distance between it and another entity in group k has the same distribution as a mean distance from it and another group.
#' Under the null hypothesis, the mean distance is no different, and we remove it from the group.
#' Under the alterantive hypothesis, the mean distance is closer, and we conclude that the entity truly belongs to the group.
#'
#' @export
identify_outliers <- function(assignment, D, B, min_group_size, prior, labels, display_progress = FALSE, omega = 1, omega0 = 1) {
    .Call(`_classCleaner_identify_outliers`, assignment, D, B, min_group_size, prior, labels, display_progress, omega, omega0)
}

#' @title test function
#' 
#' @description this is a trivial example.
#' 
#' @param vec1 a numeric vector
#' @details a trivial example to figure out why matrix multiplication is giving errors.
#' 
#' @export
test <- function(vec1) {
    .Call(`_classCleaner_test`, vec1)
}

#' @title tmp function
#' @export
sim_by_class <- function(n, Nk, s, tau, rho) {
    .Call(`_classCleaner_sim_by_class`, n, Nk, s, tau, rho)
}

sim_by_instance <- function(n, Nk, s, rho) {
    .Call(`_classCleaner_sim_by_instance`, n, Nk, s, rho)
}

